\section{Design}
This section sets out the High level program architecture and design, along with areas that are configurable and the different design choices that were made in the development of the project.

During the design of the project, efforts were made to keep the entire program modular, so all sections are reusable and replaceable.
\subsection{HTTP Analysis}
To embed data in HTTP on its own would be trivial, putting the data to send and receive as the request/response body as data, while this would get around many web filters, it would only require trivial inspection to determine it is in fact not real HTTP traffic.
For this reason, data is inserted into real websites and realistic browsing patterns, and to do this the VPN-Server will act as a website mirror when navigated to in the browser.

This means that to an observer, the VPN-Server will appear as a live mirror of a real website that updates as the original does.

When talking about how data is transferred in detail, I will refer to the client uploading, or sending data to the server as the `Request' side, and when the client downloads, or receives data from the server as the `Response' side.

Putting data in the Response side of the connection is trivial, as when a user make a HTTP request, data is returned, and it is often different even if the same request is sent multiple times.
The Request side, however is significantly more difficult. This is because when a user is browsing a website, the request doesn't significantly change, and it would be incredibly obvious to an observer if for example the `User Agent' field continuously changes. Therefore, the changes have to be subtle, and rely on the Header fields being a dictionary, so order doesn't matter, and insensitive to whitespace.

\newpage
\subsection{Server Overview}
The server is split into multiple layers.
\begin{itemize}
    \item Proxy Layer
    \item HTTP Layer
    \item Obfuscation Layer
\end{itemize}
Some of the reasons for choosing this design are:
\begin{itemize}
    \item It allows the proxy layer to deal with keeping the connection alive, and the upper levels can assume that if they are running, both of the TCP sockets are alive.
    \item It allows ease of customisation, because each layer can easily be switched out.
    \item It allows the proxy layer to provide a `data storage' to the upper threads, which is provided thread safe and reliably so they can access current data about the session.
\end{itemize}


\subsection{Proxy Layer}
The proxy layer acts as a manager for the two duplex connections that are active. This creates a TCP listening socket, and then when that socket is connected to it, it creates a connection to the remote server.
In the most basic configuration, data is read from one socket and written directly to the other, acting as a TCP-Forwarder:
\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =3 cm and 5cm ,on grid,
    semithick, state/.style={top color=white, bottom color = processblue!20, draw,processblue, text=blue, minimum width=1 cm}, line/.style={color=black,line width=0.07cm}]
\node[state] (A)[]{Remote Client};
\node[state] (B)[above=of A]{Proxy Server};
\node[state] (C)[above=of B]{Remote Server};
\draw[line] (B) to[bend right] node[left] {Data forwarded}(A);
\draw[line] (C) to[bend right] node[left] {Data sent} (B);
\draw[line] (A) to[bend right] node[right] {Data sent}(B);
\draw[line] (B) to[bend right] node[right] {Data forwarded} (C);
\end{tikzpicture}
\end{center}

The server runs two threads, one from the client to the server, and one in the return direction.\newpage
This design was chosen because it allows traffic to be `\texttt{mutated}' on the fly:
\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =3 cm and 4cm ,on grid,
    semithick, state/.style={top color=white, bottom color = processblue!20, draw,processblue, text=blue, minimum width=1 cm}, line/.style={color=black,line width=0.07cm}]
\node[state] (A)[]{Remote Client};
\node[state] (B)[above=of A]{Proxy Server};
\node[state] (C)[above=of B]{Remote Server};
\draw[line] (B) to[bend right] node[left] {Mutated data forwarded}(A);
\draw[line] (C) to[bend right] node[left] {Data sent} (B);
\draw[line] (A) to[bend right] node[right] {Data sent}(B);
\draw[line] (B) to[bend right] node[right] {Mutated data forwarded} (C);
\end{tikzpicture}
\end{center}

\subsubsection{Configurable Options}
In the proxy layer, there are lots of options that are customisable.\\
Here is an example configuration file:
\begin{verbatim}
config:
    name: localhost-http
    remote: localhost
    remote-port: 8000
    local-port: 80
    test-request: |+
        GET / HTTP/1.1
        Host: localhost
        User-Agent: Test-Agent


    test-response: HTTP/1.0 2\d\d.*
    test-response-length: 16
    proxy-mutator-location: mutators/http.py
    proxy-mutate-receive: receive
    proxy-mutate-send: send
\end{verbatim}
The config file is in yaml format.\par
The `\texttt{name}' field is just a unique identifier.\\
The `\texttt{remote}' and `\texttt{remote-port}' specify the remote host and port to connect to.\\
The `\texttt{local-port}' specifies the local port to listen on.\\
The `\texttt{test-request}' provides an example request to send to the remote server to check it is active, and the first `\texttt{test-response-length}' bytes are read from the socket and compared to the regular expression defined in `\texttt{test-response}'.\\
`\texttt{proxy-mutator-location}' is the location of the file that stores the mutator code.
`\texttt{proxy-mutate-receive}' and `\texttt{proxy-mutate-send}' are the names of the functions that are called when data is received from the remote server and needs mutating before sending to the client, and vice versa.\par
Because of all of this configuration testing connections, debugging, and attempting new things were made significantly simpler. It has also left significant scope for future expansion of the project.

\subsection{Obfuscation Layer}
The Obfuscation layer consists of three parts:
\begin{itemize}
    \item Generic structured obfuscation
    \item List-Order obfuscation
    \item Whitespace obfuscation
\end{itemize}

\subsubsection{Generic Obfuscation}
Generic obfuscation is where a structure is defined, and then data can be placed into the defined structure.
The structure is defined in a configuration file, called a `\texttt{page}' file, which sets out the structure the obfuscated data should fit into. It uses a custom configuration file format, for a number of reasons:
\begin{itemize}
    \item Easy to extend
    \item Concise
    \item Easy to understand
\end{itemize}
An example of the file format is as follows:
\begin{verbatim}
PAGE#0.1
DELIM <-

bin <-0
bin <-1 

byte <- %bin%bin%bin%bin%bin%bin%bin%bin
*out <- %byte
\end{verbatim}
This is a simple example that will print out a byte of the input at a time, but in binary.
The obfuscation was designed like this because it makes it easy to modify, extend and debug.
The obfuscation is completely reversible, and more details about how it works will be explained later.
\subsubsection{List-Order Obfuscation}
The idea behind List-Order obfuscation is that data can be stored in the order of a list, and retrieved. This is explained in detail later.

\subsubsection{Whitespace Obfuscation}
Whitespace Obfuscation is when binary data is converted to unary, and appended to whitespace insensitive fields.

\subsection{HTTP Layer}
The HTTP Layer consists of a `\texttt{mutator}' (as mentioned in the previous section), and a corresponding client. The HTTP layer understands the HTTP Protocol, and how data can be inserted into it.\par
The mutator is simply used to modify data on the HTTP layer.\par
The layer also calls the `\texttt{obfuscator}' which is used to insert data into the HTTP protocol.

\subsubsection{Listening Ports}
The HTTP layer also contains the data endpoints, which are a pair of listening HTTP Sockets, one on the server and one on the client.\par
This is where the data to be encoded is read from, and after decoding on the remote end, written to.
\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =2 cm and 6cm ,on grid,
    semithick, state/.style={top color=white, bottom color = processblue!20, draw,processblue, text=blue, minimum width=2 cm}, line/.style={color=black,line width=0.02cm}]
\node[state] (A)[]{Server};
\node[state] (B)[right=of A]{Client};
\node[state] (C)[below=of B]{Client listening socket};
\node[state] (D)[below=of A]{Server listening socket};
\draw[line] (B) to[bend right] node[above] {HTTP encoded data}(A);
\draw[line] (A) to[bend left] (B);
\draw[line] (B) -- node[right] {IO from the socket}(C);
\draw[line] (C) -- (B);
\draw[line] (A) -- node[left] {IO from the socket}(D);
\draw[line] (D) -- (A);
\end{tikzpicture}
\end{center}
Using listening ports instead of directly interfacing with an application means that there is significantly more flexibility with regards to the applications that it can be used with, because multiple applications can be connected, with minimal configuration.

\subsection{Modular Sections Overview}
The overall design of the project is to be very modular, so things can be switched out and replaced.

Below is a diagram showing all of the parts that could be switched out and replaced between the server and client.
\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =.7 cm and 6cm ,on grid,
    semithick, state/.style={top color=white, bottom color = processblue!20, draw,processblue, text=blue, minimum width=4 cm}, line/.style={color=black,line width=0.07cm}]
\node[state] (A)[]{Proxy};
\node[state] (B)[above=of A]{HTTP Mutator};
\node[state] (C)[above=of B]{Obfuscater};
\node[state] (D)[right=of B]{HTTP Client};
\node[state] (E)[right=of C]{Obfuscater};
\node[label] (F)[above=of C]{Server};
\node[label] (G)[above=of E]{Client};
\draw[line] (B) -- (D);
\draw[line] (D) -- (B);
\draw[line] (E) -- (C);
\draw[line] (C) -- (E);
\end{tikzpicture}
\end{center}
Both the server and the client have a HTTP section and an Obfuscater section.
Either of these sections (on both the server and the client) could be switched out with an equivalent pair, and it would continue to function correctly without changing other parts of the program.

\subsection{Data Buffer}
As the entire project is about transmitting data, a lot of the data transfer is built on `Data Buffers' which are essentially a bit-stream that encapsulates length, which means it's easy to tell when the bit-stream is complete.

\subsection{Server-Server adapter}
Because on both ends of the project there is a TCP listening socket, an adapter is needed which can connect two listening sockets together, because most applications will have a client/server model and therefore one listening socket and one connecting.
