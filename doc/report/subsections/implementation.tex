\section{Implementation}
In this section I am going through all of the areas of the project that I have talked about in the design section, along with discussing programming language choice and the use of libraries.

\subsection{Programming Language Choice}
For the project, I opted to use Python for a number of reasons:
\begin{itemize}
    \item Quick to develop and prototype
    \item Generally Safe
    \item Solid language design and features
\end{itemize}

On top of this, I did not know any python when I started the project, and I wanted to learn something new, which I definitely feel I did.\\
Python also has a wealth of useful libraries.

\subsection{Proxy}
As discussed previously, the proxy creates and maintains two sockets, and acts as a man in the middle between them, receiving data from one socket, mutating it with the current mutator, and then passing it on to the second socket.\par

It also verifies the config file passed to it in the following ways:
\begin{itemize}
    \item Checking the remote server has a port open and that it replies as expected
    \item Check that the functions defined exist
\end{itemize}
This helps make sure the project is stable.\par

The Proxy maintains both sockets by storing a buffer each way of data that is ready to send, but not yet sent. When the data is sent, it checks the sockets to make sure it has been sent successfully, and if it has not been it tears down the socket and rebuilds it. If the socket cannot come back up, it terminates the program.
The benefit of this is that the mutator layer above does not need to worry about maintaining sockets (however in my mutator code I do perform some basic error and sanity checking).

\subsection{Obfuscator}
The Obfuscator is split into three parts:
\begin{itemize}
    \item Generic obfuscation for structured data
    \item Steganography by mutating the order of lists
    \item Steganography by appending whitespace to non-whitespace-sensitive fields
\end{itemize}

\subsubsection{Generic Obfuscation}
The generic obfuscator that I created can be used to take any input and generate an output of structured data. This is very useful for generating things like HTML, as it is highly structured and forms a tree structure.\par
As this is for generating structured data, and in the context of this project, HTML, it is only used on the response side of the program to inject valid HTML into the page that is returned from the webserver.\par
As an example, generating simple mathematical formulae from data is demonstrated below because it is significantly simpler and less verbose than HTML, however the process is the same and it is trivial to understand.\par
The format defined for simple mathematical equations is as follows:
\begin{verbatim}
op <- *
op <- +
op <- -
op <- /
int <-1
int <-2
int <-3
int <-4
intexp <-%int
intexp <-(%intexp %op %intexp)
*exp <- %intexp %op %intexp
\end{verbatim}
As can be seen here, the format is defined recursively.
The format is the built up by selecting the top level element which in this case `\texttt{exp}' (the asterisk is only to mark that it is the top level element).
\texttt{exp} can only be represented by \texttt{\%intexp \%op \%intexp}. \\
\texttt{intexp} can be represented by a single integer, or an expression.
As there are two choices, the first bit in the bitstream will be selected and this will be used to choose between the two possible choices.
When there are more than two choices, multiple bits are used to make the decision.
This is made slightly more complicated by the fact that the bytes are read backwards, but when multiple bytes are required, they are interpreted the other way around for ease of decoding.

For example, the ASCII characters `hi' are represented by the binary `01101000 01101001'.
And as the bits are read backwards, they are used in the order: `00010110 10010110'
To start with, we have:
\texttt{\%intexp \%op \%intexp}
The \texttt{intexp} requires a single bit, and which in this case is \texttt{0}, which means it is an \texttt{int}. An \texttt{int} requires 2 bits to choose, which is \texttt{00}.
Therefore the first int is 1. The next part is the \texttt{op} which also requires two bits, \texttt{10}.\\
The order here is again flipped, which means a \texttt{+} is chosen.
This continues recursively, and results in the following: \\
\texttt{1 + ((2 \- 4) * 1)}\par
To make this clearer, the recursive tree that is generated by the format above, along with the choices to navigate each branch are defined below:

\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =3 cm and 3cm ,on grid,
    semithick, req/.style={color=blue},choice/.style={color=red,font=\small},every tree node/.style={align=center,minimum width=3em},level distance=2cm,block/.style={rectangle,draw=black,thick,text width=5cm}]
    \node[block] at(-5,0) {{\color{red}Red line means choose based on binary input}\\{\color{blue}Blue line means no choice to be made}};
\node (exp)[]{\texttt{*exp}};
\node (intexpopintexp)[below of=exp]{\texttt{\%intexp \%op \%intexp}};
\node (intexp)[below right of=intexpopintexp]{\texttt{intexp}};
\node (recintexp)[below right of=intexp]{\texttt{(\%intexp \%op \%intexp)}};
\begin{scope}[xshift=-5.65cm,yshift=-9cm]
\Tree 
[.\node (op) {\texttt{op}};
\edge[choice] node[left,pos=.8] {\texttt{00}};
	[.\node(1) {\texttt{*}};]
    \edge[choice] node[left,pos=.8] {\texttt{01}};
	[.\node(2) {\texttt{+}};]
    \edge[choice] node[right,pos=.8] {\texttt{10}};
	[.\node(3) {\texttt{-}};]
    \edge[choice] node[right,pos=.8] {\texttt{11}};
	[.\node(4) {\texttt{/}};]
]
	\begin{scope}[xshift=5cm]
	\Tree
	[.\node (int) {\texttt{int}};
    \edge[choice] node[left,pos=.8] {\texttt{00}};
		[.\node(1) {\texttt{1}};]
        \edge[choice] node[left,pos=.8] {\texttt{01}};
		[.\node(2) {\texttt{2}};]
        \edge[choice] node[right,pos=.8] {\texttt{10}};
		[.\node(3) {\texttt{3}};]
        \edge[choice] node[right,pos=.8] {\texttt{11}};
		[.\node(4) {\texttt{4}};]
	]
	\end{scope}
\end{scope}
\draw[req] (exp) to[out=-70, in=110] node {} (intexpopintexp);
\draw[req] (intexpopintexp.west) to[bend right,out=-100] node {} (intexp);
\draw[req] (intexpopintexp.east) to[bend left,out=100] node {} (intexp);
\draw[req] (intexpopintexp) to[bend left] node {} (op);
\draw[choice] (intexp.south) to[bend left,out=120,in=-90] node {\texttt{0}} (int.north);
\draw[choice] (intexp.south) to[bend left] node {\texttt{1}} (recintexp);
\draw[req] (recintexp.west) to[bend left,out=90] node {} (intexp);
\draw[req] (recintexp.east) to[bend right,out=-90] node {} (intexp);
\draw[req] (recintexp.south) to[bend right,out=90,in=-100] node {} (op);
\end{tikzpicture}
\end{center}


\subsection{HTTP Mutator}
\subsection{HTTP Client}
\subsection{Complete data flow}
