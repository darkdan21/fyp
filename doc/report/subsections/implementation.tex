\section{Implementation}
In this section I am going through all of the areas of the project that I have talked about in the design section, along with discussing programming language choice and the use of libraries.

\subsection{Programming Language Choice}
For the project, I opted to use Python for a number of reasons:
\begin{itemize}
    \item Quick to develop and prototype
    \item Generally Safe
    \item Solid language design and features
\end{itemize}

On top of this, I did not know any python when I started the project, and I wanted to learn something new, which I definitely feel I did.\\
Python also has a wealth of useful libraries.

\subsection{Proxy}
As discussed previously, the proxy creates and maintains two sockets, and acts as a man in the middle between them, receiving data from one socket, mutating it with the current mutator, and then passing it on to the second socket.\par

It also verifies the config file passed to it in the following ways:
\begin{itemize}
    \item Checking the remote server has a port open and that it replies as expected
    \item Check that the functions defined exist
\end{itemize}
This helps make sure the project is stable.\par

The Proxy maintains both sockets by storing a buffer each way of data that is ready to send, but not yet sent. When the data is sent, it checks the sockets to make sure it has been sent successfully, and if it has not been it tears down the socket and rebuilds it. If the socket cannot come back up, it terminates the program.
The benefit of this is that the mutator layer above does not need to worry about maintaining sockets (however in my mutator code I do perform some basic error and sanity checking).

\subsection{Obfuscator}
The Obfuscator is split into three parts:
\begin{itemize}
    \item Generic obfuscation for structured data
    \item Steganography by mutating the order of lists
    \item Steganography by appending whitespace to non-whitespace-sensitive fields
\end{itemize}

\subsubsection{Generic Obfuscation}
The generic obfuscator that I created can be used to take any input and generate an output of structured data. This is very useful for generating things like HTML, as it is highly structured and forms a tree structure.\par
As this is for generating structured data, and in the context of this project, HTML, it is only used on the response side of the program to inject valid HTML into the page that is returned from the webserver.\par
As an example, generating simple mathematical formulae from data is demonstrated below because it is significantly simpler and less verbose than HTML, however the process is the same and it is trivial to understand.\par
The format defined for simple mathematical equations is as follows:
\begin{verbatim}
op <- *
op <- +
op <- -
op <- /
int <-1
int <-2
int <-3
int <-4
intexp <-%int
intexp <-(%intexp %op %intexp)
*exp <- %intexp %op %intexp
\end{verbatim}
As can be seen here, the format is defined recursively.
The format is the built up by selecting the top level element which in this case `\texttt{exp}' (the asterisk is only to mark that it is the top level element).
\texttt{exp} can only be represented by \texttt{\%intexp \%op \%intexp}. \\
\texttt{intexp} can be represented by a single integer, or an expression.
As there are two choices, the first bit in the bitstream will be selected and this will be used to choose between the two possible choices.
When there are more than two choices, multiple bits are used to make the decision.
This is made slightly more complicated by the fact that the bytes are read backwards, but when multiple bytes are required, they are interpreted the other way around for ease of decoding.

For example, the ASCII characters `hi' are represented by the binary `01101000 01101001'.
And as the bits are read backwards, they are used in the order: `00010110 10010110'
To start with, we have:
\texttt{\%intexp \%op \%intexp}
The \texttt{intexp} requires a single bit, and which in this case is \texttt{0}, which means it is an \texttt{int}. An \texttt{int} requires 2 bits to choose, which is \texttt{00}.
Therefore the first int is 1. The next part is the \texttt{op} which also requires two bits, \texttt{10}.\\
The order here is again flipped, which means a \texttt{+} is chosen.
This continues recursively, and results in the following: \\
\texttt{1 + ((2 \- 4) * 1)}\par
To make this clearer, the recursive tree that is generated by the format above, along with the choices to navigate each branch are defined below:

\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =3 cm and 3cm ,on grid,
    semithick, req/.style={color=blue},choice/.style={color=red,font=\small},every tree node/.style={align=center,minimum width=3em},level distance=2cm,block/.style={rectangle,draw=black,thick,text width=5cm}]
    \node[block] at(-5,0) {{\color{red}Red line means choose based on binary input}\\{\color{blue}Blue line means no choice to be made}};
\node (exp)[]{\texttt{*exp}};
\node (intexpopintexp)[below of=exp]{\texttt{\%intexp \%op \%intexp}};
\node (intexp)[below right of=intexpopintexp]{\texttt{intexp}};
\node (recintexp)[below right of=intexp]{\texttt{(\%intexp \%op \%intexp)}};
\begin{scope}[xshift=-5.65cm,yshift=-9cm]
\Tree 
[.\node (op) {\texttt{op}};
\edge[choice] node[left,pos=.8] {\texttt{00}};
	[.\node(1) {\texttt{*}};]
    \edge[choice] node[left,pos=.8] {\texttt{01}};
	[.\node(2) {\texttt{+}};]
    \edge[choice] node[right,pos=.8] {\texttt{10}};
	[.\node(3) {\texttt{-}};]
    \edge[choice] node[right,pos=.8] {\texttt{11}};
	[.\node(4) {\texttt{/}};]
]
	\begin{scope}[xshift=5cm]
	\Tree
	[.\node (int) {\texttt{int}};
    \edge[choice] node[left,pos=.8] {\texttt{00}};
		[.\node(1) {\texttt{1}};]
        \edge[choice] node[left,pos=.8] {\texttt{01}};
		[.\node(2) {\texttt{2}};]
        \edge[choice] node[right,pos=.8] {\texttt{10}};
		[.\node(3) {\texttt{3}};]
        \edge[choice] node[right,pos=.8] {\texttt{11}};
		[.\node(4) {\texttt{4}};]
	]
	\end{scope}
\end{scope}
\draw[req] (exp) to[out=-70, in=110] node {} (intexpopintexp);
\draw[req] (intexpopintexp.west) to[bend right,out=-100] node {} (intexp);
\draw[req] (intexpopintexp.east) to[bend left,out=100] node {} (intexp);
\draw[req] (intexpopintexp) to[bend left] node {} (op);
\draw[choice] (intexp.south) to[bend left,out=120,in=-90] node {\texttt{0}} (int.north);
\draw[choice] (intexp.south) to[bend left] node {\texttt{1}} (recintexp);
\draw[req] (recintexp.west) to[bend left,out=90] node {} (intexp);
\draw[req] (recintexp.east) to[bend right,out=-90] node {} (intexp);
\draw[req] (recintexp.south) to[bend right,out=90,in=-100] node {} (op);
\end{tikzpicture}
\end{center}

The tree is navigated until either the input is exhausted, which means the stream is considered a stream of 0's, or the tree is completed, in which case a new tree is started.

\newpage
\subsubsection{Appending Whitespace}
Appending whitespace to whitespace insensitive fields is a simple way to insert more data into the header of the HTTP request, because as in previous sections it is assumed that if the traffic was being inspected, it would be sanitised before inspection. \\
Whitespace can be added up to a customisable maximum, which represents data.
The way this works is by utilising `\texttt{unary}', which is where a number is represented by a number of items.
In the project, a maximum of 16 spaces (or 4 bits) is used, for example, 7 spaces out of a maximum of 16 would represent `0111'.

\subsubsection{Shuffling the order of lists}
HTTP headers are stored as a dictionary, which means that we can reorder them, and the remote server, nor anyone listening to the traffic are likely to notice.
If we have a list of 14 elements:\\
`\texttt{A B C D E F G H I J K L M N}'
Simple maths would dictate that data can be stored in the order of the list.\\
In a list of 14 elements, there are $\Factorial{14}$ or $87178291200$ different ways to order the list.
This means that there are $\Log[2]{\Factorial{14}}$, or roughly $36$ bits, or around 4 bytes of data that can be stored.\par
The algorithm that I came up with resembles quicksort, however instead of comparing two elements to each other, the next bit of a bitstream is used to decide the order.
Here is some side-by-side python to demonstrate this, and differences are highlighted:
\lstset{frame=tb,
  language=Python,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\scriptsize\ttfamily},
  numbers=left,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  framerule=0pt,
  tabsize=2,
  stepnumber=1,
  escapeinside=\@\@,
}
\vspace{0.5cm}
\hrule
{\setlength\multicolsep{0pt}
\begin{multicols}{2}
\begin{lstlisting}
def @\colorbox{yellow}{quicksort}@(lst):
    if len (lst) <= 1:
        return lst

    pivot = lst[0]
    lst = lst[1:]
    first = []
    second = []
    for item in lst:
        if @{\colorbox{yellow}{item <= pivot}}@:
            first.append (item)
        else:
            second.append (item)
        return @\colorbox{yellow}{quicksort}@(first)
            +[pivot]
            +@\colorbox{yellow}{quicksort}@(second)
\end{lstlisting}
\begin{lstlisting}
def @\colorbox{yellow}{shuffle}@ (lst @\colorbox{yellow}{,datasource}@):
    if len (lst) <= 1: 
        return lst 

    pivot = lst[0]
    lst = lst[1:]
    first = []
    second = []
    for item in lst:
        if @{\colorbox{yellow}{datasource.getbit () == 1}}@:
            first.append (item)
        else:
            second.append (item)
        return @\colorbox{yellow}{shuffle}@ (first,@\colorbox{yellow}{datasource}@)
            +[pivot]
            +@\colorbox{yellow}{shuffle}@ (second,@\colorbox{yellow}{datasource}@)
\end{lstlisting}
\end{multicols}}
\hrule
\newpage
If the datasource defined above is for the word `\texttt{data}' (which in binary is:
\texttt{00100110 10000110 00101110 10000110}*), and it was input into the function, it would be broken down into a tree as follows:\\
{\tiny *Note that the binary is least significant bit first, rather than the more conventional most significant bit first.}

\tikzset{every tree node/.style={align=center,minimum width=2.5em},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw,edge from parent path={(\tikzparentnode)-- (\tikzchildnode)}},
         level distance=2cm}

\vspace{0.4cm}
\begin{tikzpicture}
\Tree
[.{\texttt{A B C D E F G H I J K L M N} \\ \texttt{\# 0 0 1 0 0 1 1 0 1 0 0 0 0}}
    [.{\texttt{D G H J} \\ \texttt{\# 1 1 0}}
        [.{\texttt{G H} \\ \texttt{\# 0}}
        \edge[blank];\node[blank]{};
            [.{\texttt{H} \\ \texttt{\#}} ]
        ]
        [.{\texttt{J} \\ \texttt{\#} } ]
    ]
    [.{\texttt{B C E F I K L M N} \\ \texttt{\# 0 1 0 1 1 1 0 1}}
        [.{\texttt{E I K L N} \\ \texttt{\# 0 0 0 0}}
        \edge[blank];\node[blank]{};
        [.{\texttt{I K L N} \\ \texttt{\# 1 1 0}}
        [.{\texttt{K L} \\ \texttt{\# 0}}
        \edge[blank];\node[blank]{};
                [.{\texttt{L} \\ \texttt{\#}} ]
        ]
        [.{\texttt{N} \\ \texttt{\#}} ]
        ]
        ]
        [.{\texttt{C F M} \\ \texttt{\# 0 0}}
        \edge[blank];\node[blank]{};
            [.{\texttt{F M} \\ \texttt{\# 0}}
        \edge[blank];\node[blank]{};
                [.{\texttt{M} \\ \texttt{\#}} ]
            ]
         ] ]
    ]
\end{tikzpicture}
\vspace{0.5cm}\\
At each node, the first element (marked with a `\texttt{\#}') represents the `pivot' in the quicksort. The binary below each element is for deciding whether the element should go left (\texttt{1}) or right (\texttt{0}).\par
The output from encoding `data' into the order of:\\
`\texttt{A B C D E F G H I J K L M N}' is:\\
'\texttt{G H D J A E K L I N B C F M}'\par
\vspace{0.3cm}
The binary is put into the tree in a depth first fashion, and in order to get the order of the list back out of the tree, it is traversed in-order.\par
To get the binary data back out from the reordered list is trivial, the tree is just built up, and then the binary can be easily extracted.\par

\newpage
One side effect of building a tree based on binary data is that depending what the data to be encoded is, a different number of bits will be encoded*:

\begin{table}[ht]
\begin{tabular}{@{}rllll@{}}
\toprule
Type of data & English Text & Random Data & Binary 0's & Repeated `U's \\ \midrule
Bits Encoded & 482 & 493 & 4851 & 474 \\ \bottomrule
\end{tabular}
\end{table}
{\tiny * The Random data test was run 100 times and this is the average.The english data test was run on different data from Lorem Ipsum 100 times and this is the average. The binary 0's is a repeated binary steam of 0's.The Repeated U's is binary switching between 1 and 0 (The binary representation of U in ASCII is 0$\times$10101010).}\par
\vspace{0.5cm}
It is notable that English text gets fewer bits encoded than random data, which is very different to different compression schemes.\par
\vspace{0.5cm}
This idea can be applied to HTTP headers, to get data from the client to the server.

\subsection{HTTP Mutator}


\subsection{HTTP Client}
\subsection{Complete data flow}
