\lstset{frame=tb,
  language=Python,
  columns=flexible,
  basicstyle={\scriptsize\ttfamily},
  numbers=left,
  keywordstyle=\color{blue},
  commentstyle=\color{green},
  stringstyle=\color{mauve},
  breaklines=true,
  framerule=0pt,
  tabsize=2,
  stepnumber=1,
  escapeinside=\@\@,
}
\lstdefinelanguage{pagefile}{% list of keywords
  morekeywords={DELIM,PAGE},
  otherkeywords = {<-,\%,*},
  sensitive=false, % keywords are not case-sensitive
  morecomment=[s]{\{}{\}}
}

\section{Implementation}
In this section all of the areas of the project that have been talked about in the design section are discussed in detail.

\subsection{Programming Language Choice}
For the project, I opted to use Python for a number of reasons:
\begin{itemize}
    \item Quick to develop and prototype
    \item Generally Safe
    \item Solid language design and features
    \item Wealth of useful libraries
\end{itemize}

\subsection{Proxy}
As discussed previously, the proxy creates and maintains two sockets, and acts as a `\texttt{man in the middle}' between them, receiving data from one socket, mutating it with the current mutator, and then passing it on to the second socket.\par

It also verifies the config file passed to it in the following ways:
\begin{itemize}
    \item Checking the remote server has a port open and that it replies as expected
    \item Check that the functions defined exist
\end{itemize}
This helps make sure the project is stable.\par

The Proxy maintains both sockets by storing a buffer each way of data that is ready to send, but not yet sent. When the data is sent, it checks the sockets to make sure it has been sent successfully, and if it has not been it tears down the socket and rebuilds it. If the socket cannot come back up, it terminates the program.
\subsection{Obfuscator}
The Obfuscator is split into three parts:
\begin{itemize}
    \item Generic obfuscation for structured data
    \item Steganography by mutating the order of lists
    \item Steganography by appending whitespace to non-whitespace-sensitive fields
\end{itemize}

\subsubsection{Generic Obfuscation}
The generic obfuscator that I created can be used to take any input and generate an output of structured data. This is very useful for generating tree-like structures like HTML, as it is highly structured.\par
As this is for generating structured data, and in the context of this project, HTML, it is only used on the response side of the program to inject valid HTML into the page that is returned from the webserver.\par
As an example, generating simple mathematical formulae from data is demonstrated below because it is significantly simpler and less verbose than HTML, however the process is the same and it is simpler to understand.\par
The format defined for simple mathematical equations is as follows:
\begin{lstlisting}[language=pagefile]
op <- *
op <- +
op <- -
op <- /
int <-1
int <-2
int <-3
int <-4
intexp <-%int
intexp <-(%intexp %op %intexp)
*exp <- %intexp %op %intexp
\end{lstlisting}

As can be seen here, the format is defined recursively.
The format is the built up by selecting the top level element which in this case `\texttt{exp}' (the asterisk is only to mark that it is the top level element).
\texttt{exp} can only be represented by \texttt{\%intexp \%op \%intexp}. \\
\texttt{intexp} can be represented by a single integer, or an expression.
As there are two choices, the first bit in the bitstream will be selected and this will be used to choose between the two possible choices.
When there are more than two choices, multiple bits are used to make the decision.
This is made slightly more complicated by the fact that the bytes are read backwards, but when multiple bytes are required, they are interpreted the other way around for ease of decoding.

For example, the ASCII characters `hi' are represented by the binary `01101000 01101001'.
And as the bits are read backwards, they are used in the order: `00010110 10010110'
To start with, we have:
\texttt{\%intexp \%op \%intexp}
The \texttt{intexp} requires a single bit, and which in this case is \texttt{0}, which means it is an \texttt{int}. An \texttt{int} requires 2 bits to choose, which is \texttt{00}.
Therefore the first int is 1. The next part is the \texttt{op} which also requires two bits, \texttt{10}.\\
The order here is again flipped, which means a \texttt{+} is chosen.
This continues recursively, and results in the following: \\
\texttt{1 + ((2 \- 4) * 1)}\par
To make this clearer, the recursive tree that is generated by the format above, along with the choices to navigate each branch are defined below:

\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =3 cm and 3cm ,on grid,
    semithick, req/.style={color=blue},choice/.style={color=red,font=\small},every tree node/.style={align=center,minimum width=3em},level distance=2cm,block/.style={rectangle,draw=black,thick,text width=5cm}]
    \node[block] at(-5,0) {{\color{red}Red line means choice based on binary input}\\{\color{blue}Blue line means no choice to be made}};
\node (exp)[]{\texttt{*exp}};
\node (intexpopintexp)[below of=exp]{\texttt{\%intexp \%op \%intexp}};
\node (intexp)[below right of=intexpopintexp]{\texttt{intexp}};
\node (recintexp)[below right of=intexp]{\texttt{(\%intexp \%op \%intexp)}};
\begin{scope}[xshift=-5.65cm,yshift=-9cm]
\Tree 
[.\node (op) {\texttt{op}};
\edge[choice] node[left,pos=.8] {\texttt{00}};
	[.\node(1) {\texttt{*}};]
    \edge[choice] node[left,pos=.8] {\texttt{01}};
	[.\node(2) {\texttt{+}};]
    \edge[choice] node[right,pos=.8] {\texttt{10}};
	[.\node(3) {\texttt{-}};]
    \edge[choice] node[right,pos=.8] {\texttt{11}};
	[.\node(4) {\texttt{/}};]
]
	\begin{scope}[xshift=5cm]
	\Tree
	[.\node (int) {\texttt{int}};
    \edge[choice] node[left,pos=.8] {\texttt{00}};
		[.\node(1) {\texttt{1}};]
        \edge[choice] node[left,pos=.8] {\texttt{01}};
		[.\node(2) {\texttt{2}};]
        \edge[choice] node[right,pos=.8] {\texttt{10}};
		[.\node(3) {\texttt{3}};]
        \edge[choice] node[right,pos=.8] {\texttt{11}};
		[.\node(4) {\texttt{4}};]
	]
	\end{scope}
\end{scope}
\draw[req] (exp) to[out=-70, in=110] node {} (intexpopintexp);
\draw[req] (intexpopintexp.west) to[bend right,out=-100] node {} (intexp);
\draw[req] (intexpopintexp.east) to[bend left,out=100] node {} (intexp);
\draw[req] (intexpopintexp) to[bend left] node {} (op);
\draw[choice] (intexp.south) to[bend left,out=120,in=-90] node {\texttt{0}} (int.north);
\draw[choice] (intexp.south) to[bend left] node {\texttt{1}} (recintexp);
\draw[req] (recintexp.west) to[bend left,out=90] node {} (intexp);
\draw[req] (recintexp.east) to[bend right,out=-90] node {} (intexp);
\draw[req] (recintexp.south) to[bend right,out=90,in=-100] node {} (op);
\end{tikzpicture}
\end{center}

The tree is navigated until either the input is exhausted, which means the stream is considered a stream of 0's, or the tree is completed, in which case a new tree is started.

\newpage
\subsubsection{Appending Whitespace}
Appending whitespace to whitespace insensitive fields is a simple way to insert more data into the header of the HTTP request, because as in previous sections it is assumed that if the traffic was being inspected, it would be sanitised before inspection. \\
Whitespace can be added up to a customisable maximum, which represents data.
The way this works is by utilising `\texttt{unary}', which is where a number is represented by a number of items.
In the project, a maximum of 16 spaces (or 4 bits) is used, for example, 7 spaces out of a maximum of 16 would represent `0111'.

\subsubsection{Shuffling the order of lists}
HTTP headers are stored as a dictionary, which means that we can reorder them, and the remote server, nor anyone listening to the traffic are likely to notice.
If we have a list of 14 elements:\\
`\texttt{A B C D E F G H I J K L M N}'\\
Simple maths would dictate that data can be stored in the order of the list.\\
In a list of 14 elements, there are $\Factorial{14}$ or $87178291200$ different ways to order the list.
This means that there are $\Log[2]{\Factorial{14}}$, or roughly $36$ bits, or around 4 bytes of data that can be stored.\par
The algorithm that I devised resembles quicksort, however instead of comparing two elements to each other, the next bit of a bitstream is used to decide the order.\\
Here is some side-by-side python to demonstrate this, and differences are highlighted:
\vspace{0.5cm}
\hrule
{\setlength\multicolsep{0pt}
\begin{multicols}{2}
\begin{lstlisting}
def @\colorbox{yellow}{quicksort}@(lst):
    if len (lst) <= 1:
        return lst

    pivot = lst[0]
    lst = lst[1:]
    first = []
    second = []
    for item in lst:
        if @{\colorbox{yellow}{item <= pivot}}@:
            first.append (item)
        else:
            second.append (item)
        return @\colorbox{yellow}{quicksort}@(first)
            +[pivot]
            +@\colorbox{yellow}{quicksort}@(second)
\end{lstlisting}
\begin{lstlisting}
def @\colorbox{yellow}{shuffle}@ (lst @\colorbox{yellow}{,datasource}@):
    if len (lst) <= 1: 
        return lst 

    pivot = lst[0]
    lst = lst[1:]
    first = []
    second = []
    for item in lst:
        if @{\colorbox{yellow}{datasource.getbit () == 1}}@:
            first.append (item)
        else:
            second.append (item)
        return @\colorbox{yellow}{shuffle}@ (first,@\colorbox{yellow}{datasource}@)
            +[pivot]
            +@\colorbox{yellow}{shuffle}@ (second,@\colorbox{yellow}{datasource}@)
\end{lstlisting}
\end{multicols}}
\hrule
\newpage
If the datasource defined above is for the word `\texttt{data}' (which in binary is:
\texttt{00100110 10000110 00101110 10000110}*), and it was input into the function, it would be broken down into a tree as follows:\\
{\tiny *Note that the binary is least significant bit first, rather than the more conventional most significant bit first.}

\tikzset{every tree node/.style={align=center,minimum width=2.5em},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw,edge from parent path={(\tikzparentnode)-- (\tikzchildnode)}},
         level distance=2cm}

\vspace{0.4cm}
\begin{tikzpicture}
\Tree
[.{\texttt{A B C D E F G H I J K L M N} \\ \texttt{\# 0 0 1 0 0 1 1 0 1 0 0 0 0}}
    [.{\texttt{D G H J} \\ \texttt{\# 1 1 0}}
        [.{\texttt{G H} \\ \texttt{\# 0}}
        \edge[blank];\node[blank]{};
            [.{\texttt{H} \\ \texttt{\#}} ]
        ]
        [.{\texttt{J} \\ \texttt{\#} } ]
    ]
    [.{\texttt{B C E F I K L M N} \\ \texttt{\# 0 1 0 1 1 1 0 1}}
        [.{\texttt{E I K L N} \\ \texttt{\# 0 0 0 0}}
        \edge[blank];\node[blank]{};
        [.{\texttt{I K L N} \\ \texttt{\# 1 1 0}}
        [.{\texttt{K L} \\ \texttt{\# 0}}
        \edge[blank];\node[blank]{};
                [.{\texttt{L} \\ \texttt{\#}} ]
        ]
        [.{\texttt{N} \\ \texttt{\#}} ]
        ]
        ]
        [.{\texttt{C F M} \\ \texttt{\# 0 0}}
        \edge[blank];\node[blank]{};
            [.{\texttt{F M} \\ \texttt{\# 0}}
        \edge[blank];\node[blank]{};
                [.{\texttt{M} \\ \texttt{\#}} ]
            ]
         ] ]
    ]
\end{tikzpicture}
\vspace{0.5cm}\\
At each node, the first element (marked with a `\texttt{\#}') represents the `pivot' in the quicksort. The binary below each element is for deciding whether the element should go left (\texttt{1}) or right (\texttt{0}).\par
The output from encoding `data' into the order of:\\
`\texttt{A B C D E F G H I J K L M N}' is:\\
'\texttt{G H D J A E K L I N B C F M}'\par
\vspace{0.3cm}
The binary is put into the tree in a depth first fashion, and in order to get the order of the list back out of the tree, it is traversed in-order.\par
To get the binary data back out from the reordered list is trivial, the tree is just built up, and then the binary can be easily extracted.\par

\newpage
One side effect of building a tree based on binary data is that depending what the data to be encoded is, a different number of bits will be encoded*:

\begin{table}[ht]
\begin{tabular}{@{}rllll@{}}
\toprule
Type of data & English Text & Random Data & Binary 0's & Repeated `U's \\ \midrule
Bits Encoded & 482 & 493 & 4851 & 474 \\ \bottomrule
\end{tabular}
\end{table}
{\tiny * The Random data test was run 100 times and this is the average.The english data test was run on different data from Lorem Ipsum 100 times and this is the average. The binary 0's is a repeated binary steam of 0's.The Repeated U's is binary switching between 1 and 0 (The binary representation of U in ASCII is 0b10101010).}\par
\vspace{0.5cm}
It is notable that English text gets fewer bits encoded than random data, which is very different to different compression schemes.\par
\vspace{0.5cm}
This idea can be applied to HTTP headers, to get data from the client to the server.

\subsection{HTTP Mutator}
The HTTP Mutator is the layer that understands HTTP, and where data can be inserted.
To make this work, I had to implement a the HTTP protocol to a level where every part of it can be manipulated. I started of by using libraries, but the library support was not there for chunked encoding, or modifying requests and forwarding them on.\par
Implementing HTTP was not too difficult, as it is a plaintext protocol that is reasonably well defined, however in order to make it work, all of the different compression types have to be handled. I chose to strip the compression out rather than spend time implementing lots of variations on the same compression scheme.\par

\subsubsection{Inserting HTML-encoded data}
In order to insert HTML-encoded data in a sensible place, there are a some problems to solve:
\begin{itemize}
    \item The length of the HTML-encoded data will change
    \item The length of the initial HTML will change
    \item The position of the HTML-encoded data needs to be calculated
\end{itemize}

The solution I came up with to solve the above issues is twofold.\par
Firstly, the data is encoded with a length appended to the front.
The length is in ASCII which while being more inefficient from a data-storage perspective, provides a token that allows the program to be certain that if for a given section of HTML the HTML can be decoded into data, and the data is the same length as expected that it is in fact the data to be decoded.\par
Secondly, there are only a limited number of places the data can be inserted. The number of valid `insertion' points (where HTML can be correctly inserted) is counted, and then a function is run which generates the following sequence of numbers:
\begin{lstlisting}
1
12
70
376
1992
10524
55573
293432
1549327
8180453
\end{lstlisting}
The last valid insertion point is used to insert the data.
The code used to generate the numbers is:
\begin{lstlisting}
def get_position(length):
    current = 1
    next = 1

    while(next < length):
        current = next
        next += current*1.2+2
        next += next*1.4 + 2
        next = int(next)
    return current
\end{lstlisting}
This sequence was used because it provides a small number of points to test to see if data is present, and it expands exponentially, but starts quite slow. There was a lot of testing and trial and error to get a sensible function.
Typically a HTML page doesn't have even \texttt{55573} `insertion' points, however in testing, pages with up to \texttt{300,000} insertion points were found.

\subsubsection{Chunked Encoding}
Chunked encoding differs from standard HTTP by not sending the length of the entire response, but sending it in chunks, and sending the length of each chunk individually.
More headers can also be sent with each chunk, and the webserver does not have to inform the client when all of the chunks have been sent. All of these complicate the matter of receiving data via chunked encoding.\par
To solve these issues, the program concatenates multiple chunks together before inserting the extra HTML-encoded data inside.

\subsection{HTTP Client}
The HTTP client makes HTTP requests to the server, and data is encoded by changing the order of the headers and appending whitespace, as previously explained.\par
To make the HTTP Requests, the Python Requests library is used. When headers are added to the requests created by the requests library, it does not preserve the order they are added in thus the client modifies the fields directly inside the library.\par
HTTP is a response/request protocol, so the client has to poll the server at regular intervals to check to see if the server has any data to return. If the server returns any data encoded into the HTML response, the client waits for a short amount of time before requesting another page. This continues until the server returns no data when the client goes back to polling at regular intervals. The same behavior occurs if the client has any data to send to the server, it makes frequent requests until all of the data has been sent.

\subsection{Complete data flow}
\subsubsection{Configuration}
In this section, an end to end data flow is going to be explained by sending short messages in both directions with a direct connection to the TCP sockets exposed by the client and server of the program. All of the data here is present in a wireshark capture which is submitted as an appendix.\par
\vspace{0.2cm}

\texttt{netcat} is used to connect to listening socket on each computer.\par
\vspace{0.2cm}

The program has been set up as follows on two separate computers:

\begin{center}
\begin{tikzpicture}[-latex ,auto ,node distance =2 cm and 6cm ,on grid,
    semithick, state/.style={top color=white, bottom color = processblue!20, draw,processblue, text=blue, minimum width=2 cm}, line/.style={color=black,line width=0.02cm}]
\node[state] (A)[]{\texttt{./proxy.py config/cs-bham-http.yaml}};
\node[state] (B)[below=4cm of A]{\texttt{./client.py http://computer1}};
\node[state] (C)[below=of B]{\texttt{nc localhost 33333}};
\node[state] (D)[above=of A]{\texttt{nc localhost 44444}};
\node[fit=(A)(D), draw, thick, inner sep=0.2cm, blue,minimum width=9cm](PC1){};
\node (PC1l) [right=of PC1] {Computer 1};
\node[fit=(B)(C), draw, thick, inner sep=0.2cm, blue,minimum width=9cm](PC2){};
\node (PC2l) [right=of PC2] {Computer 2};
\draw[line] (B) to[bend right] node[right] {Wireshark recording all packets}(A);
\draw[line] (A) to[bend left] (B);
\draw[line] (B) -- node[right] {}(C);
\draw[line] (C) -- (B);
\draw[line] (A) -- node[left] {}(D);
\draw[line] (D) -- (A);
\end{tikzpicture}
\end{center}
\newpage
\subsubsection{Encoded Whitespace}
The first request with data encoded in it is:
\begin{lstlisting}[basicstyle={\ttfamily},breaklines=true,numbers=none,showstringspaces=true,showlines=true,showspaces=false]
GET / HTTP/1.1
Content-Length: 0                          (26)
X-Request-ID: 8a5da39b-a61f-44eb-8952-c19ad81f3817                                         (41)
Accept-Encoding: gzip, deflate             (13)
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36       (7)
Pragma: no-cache        (8)
Cookie: _ga=GA1.3.1924440076.1506628216                                         (41)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8             (13)
Referer: google.com       (7)
Accept-Language: en-US,en;q=0.9,en-GB;q=0.8        (8)
Connection: keep-alive                                 (33)
Host: www.cs.bham.ac.uk (1)
Cache-Control: no-cache                  (18)
DNT: 1                           (27)
Upgrade-Insecure-Requests: 1                                     (37)

\end{lstlisting}
The numbers at the end of each line are the number of spaces.
For the purposes of demonstration, the number of bits transferred in whitespace have been increased, and there are a maximum of 64 spaces per line, which means 6 bits/header.
The first number is \texttt{26}, which is \texttt{11010} in binary.
However, this is only 5 binary digits, and each line represents 6, so a 0 is appended to the start, resulting in: \texttt{011010}. As previously, the binary is transferred as least significant bit first, which means the order is reversed to \texttt{010110}.
Therefore, the binary from appending whitespace is the following:\\
\texttt{010110100101101100111000000100100101101100\\
111000000100100001100000010010110110101001}\\
\vspace{0.3cm}
\subsubsection{Reordering of headers}
In the example above, the headers are out of order, and data is stored in the order of them.
To get the data back out, the list is sorted, and the first item is taken to act as a `pivot', which is the \texttt{Accept:} header.
The sorted list is then compared to the original list, and for every element in the sorted list that appears before \texttt{Accept:} a 1 is output, and if it appears afterwards, a 0 is output.
For the top level, this results in the following binary output: \texttt{1000110010011}, and this is recursed upon on each sub-list (before and after the pivot).
When this has been repeated for all of the sub-lists until the sublists are empty, the following data is output:\\
\texttt{1000110010011100010111000010101000}.\\
This is appended to the start of the previous binary stream, and is half of the data we need for the current data.
\subsubsection{Client Side remainder}
The rest of the data is in another request, and is:\\
\texttt{1011001110110011101000011011100110101001\\
1010000100010100000000000000000000000000\\
000000000000000000000000000000000000000}\\
Lots of the data is 0's, and this is because when the whitespace is appended to the headers, if no whitespace is appended, that represents only 0's.
To get the initial data out, we append the current data to the end of this, and then reverse all of it.\\
The first 24 bits of this are:\\
\texttt{100011001001110001011100}\\
Which is \texttt{:91} in ascii. However, this is backwards, and when it is reversed it tells us that the length is 19. Therefore, to get the full data out, we have to read the next $19 * 8 = 152$ bits.\\
This means the resulting message is:\par
\texttt{This is a message!}

\newpage
\subsubsection{Data encoded in HTML}
To encapsulate data in the HTTP Response (from the server to the client), data is encoded into the HTML response.

The config file used to generate the HTML to insert into the page is as follows, and the binary value for each choice is appended to end of each line and highlighted (the order may seem strange, but this is because of the bit-order):
\begin{lstlisting}[language=pagefile]
PAGE#0.1
DELIM <-

num <- 6 {00}
num <- 7 {10}
num <- 8 {01} 
num <- 9 {11}

url <- https://en.wikipedia.org/wiki/Standards-compliant {000}
url <- https://en.wikipedia.org/wiki/The_Remaining_Documents_of_Talaat_Pasha {100}
url <- https://en.wikipedia.org/wiki/Millettia_pinnata {010}
url <- https://en.wikipedia.org/wiki/Lance_Tait {110}
url <- https://en.wikipedia.org/wiki/Doll,_Highland {001}
url <- https://en.wikipedia.org/wiki/Wilf_Spooner {101}
url <- https://en.wikipedia.org/wiki/May_Moustafa {011}
url <- https://en.wikipedia.org/wiki/London_District_Signals {111}

text <- Statement #4 {00}
text <- Rubber ducks are planning world domination {10}
text <- This is text? {01}
text <- Save water, drink beer {10}


3dnum <- %num%num%num

imgbase <- http://lorempixel.com {0}
imgurl <- %imgbase/%3dnum/%3dnum {1}

tags <- <h1>%text</h1> {000}
tags <- <h2>%text<h2> {100}
tags <- <p>%text</p> {010}
tags <- <div>%tags</div> {110}
tags <- <span>%tags</span> {001}
tags <- <img src=%imgurl /> {101}
tags <- <a href=%url>%text</a> {011}
tags <- <a href=%url>%tags</a> {111}

content <- <br /> {0}
content <- %content<br>%tags {1}

*htmlbody <- %content
\end{lstlisting}
In the example, the data is inserted into position 70, and below is the first section of this:
\begin{lstlisting}[language=HTML,numbers=none]
<br />
<br />
<br />
<br />
<br /><br><h1>Statement #4</h1><br><div><span><span><h2>Rubber ducks are planning world domination<h2></span></span></div>
<br /><br><div><p>Statement #4</p></div>
<br />
\end{lstlisting}
The lines with just \texttt{<br />} are just the bit \texttt{0}, as defined in the file above.
The next line is slightly more complex.
To calculate the value of it, the `\texttt{leaf}' nodes are replaced with their binary value and the type of node like so:
\begin{lstlisting}[numbers=none]
%content:0%<br><h1>%text:00%</h1><br><div><span><span><h2>%text:10%<h2></span></span></div>
\end{lstlisting}
The next step is to parse valid patterns, so for example a \texttt{tag} can be a \texttt{<h1>\%text</h1>}, and repeat.\\
Each step is shown below:
\begin{lstlisting}[numbers=none]
%content:1000000%<br><div><span>%tags:00110010%</span></div>
%content:1000000%<br><div>%tags:00100110010%</div>
%content:1100000011000100110010%
%htmlbody:1100000011000100110010%
\end{lstlisting}
As \texttt{htmlbody} is the top-level, this is the output:\\
\texttt{1100000011000100110010}\\
Adding in the previous 0's, we get:\\
\texttt{00001100000011000100110010}\\
This is only a portion of the data in the request, but the entirety of it is:
\begin{lstlisting}[numbers=none,breaklines=true,breakatwhitespace=false]
000011000000110001001100101011001000001001110110001001100000010000101110000101101001
011011001110001101000000010010010110110011100000010010000110000001000100111010100110
1100111000001110111101100111011011001110101001100111010001010000
\end{lstlisting}
Which when converted to ASCII is:\\
\texttt{0025And this, is a response.}\\
The 4 digit number at the start is the length in bytes of the message that has been sent, and the length is sent in ASCII for the reasons described in the previous section.

\subsubsection{Note on binary reordering}
In the previous sections, there is a lot of reversing the order of bits and bytes etc, this is because in the implementation, I used treated the binary byte order as least significant bit first, which is different to the typical use. There is no real reason for this, and no advantages/disadvantages, aside from that it makes it slightly more difficult to explain.
